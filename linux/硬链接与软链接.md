# 硬链接与软链接

## 一句话总结
- 硬链接：是原始文件的“分身”或“别名”。它和原始文件平起平坐，指向硬盘上完全相同的数据块。删除一个，只要还有别的链接在，数据就还在。

- 软链接：是原始文件的“快捷方式”或“路标”。它是一个独立的、特殊的小文件，里面只保存着目标文件的路径。如果原始文件被删除，这个快捷方式就失效了。

## 详细对比
| 特性 | 硬链接 | 软链接（符号链接） |
| :--- | :--- | :--- |
| **本质** | 是同一个文件的另一个**入口/名称** | 是一个**特殊的文本文件**，存储着目标文件的路径 |
| **inode 号** | **与原始文件相同** | 与原始文件**不同**（拥有自己的 inode） |
| **存储内容** | **直接指向硬盘上的数据块** | 存储的是**目标文件的路径字符串** |
| **跨文件系统** | **不支持**（不能链接到不同磁盘或分区） | **支持** |
| **链接目录** | 通常**不允许**（防止在文件系统中形成循环） | **允许** |
| **原始文件被删除** | **不受影响**（数据依然存在，直到所有硬链接被删除） | **立即失效**（成为“断链”或“悬空链接”） |
| **文件大小** | 与原始文件相同（因为它们就是同一个文件） | 很小（只是路径字符串的长度） |
| **示例命令** | `ln [原文件] [硬链接名]` | `ln -s [原文件] [软链接名]` |

### 深入理解：inode 是关键

要真正理解区别，你需要知道一点 Linux/Unix 文件系统的基础知识：**inode**。
*   你可以把 **inode** 想象成文件的“身份证”或“索引条目”。每个文件都有一个唯一的 inode 号码。
*   inode 里存储着文件的**元数据**（metadata），如权限、所有者、文件大小、时间戳以及最重要的——**指向文件数据在硬盘上具体位置的指针**。
*   **文件名**只是我们人类便于记忆的标签，系统真正通过 inode 号来识别文件。
现在，我们来看两种链接是如何工作的：

#### 硬链接的工作原理

当你创建一个硬链接时，你实际上是**为同一个 inode 创建了另一个文件名（标签）**。
```bash
# 假设有一个文件 original.txt
echo "Hello World" > original.txt

# 为它创建一个硬链接
ln original.txt hardlink.txt

# 查看它们的 inode 号，会发现是一样的！
ls -li original.txt hardlink.txt
```

输出会类似：
```test
123456 -rw-r--r--  2 user  group  12 Jan 1 12:00 hardlink.txt
123456 -rw-r--r--  2 user  group  12 Jan 1 12:00 original.txt
# ^^^^^ 相同的 inode 号
```

`original.txt` 和 `hardlink.txt` 就像一个人的大名和小名，指向的是同一个身体（数据）。删除 `original.txt`（大名），`hardlink.txt`（小名）依然可以正常访问到“身体”（数据）。只有当所有名字（硬链接）都被删除，inode 的链接数降为 0 时，系统才会真正回收数据块。

#### 软链接的工作原理

当你创建一个软链接时，你实际上是**创建了一个全新的、特殊的小文件**，这个文件有**自己的 inode**，它的内容不是数据，而是**目标文件的路径字符串**。

```bash
# 创建软链接
ln -s original.txt softlink.txt

# 查看 inode 号，它们不同！
ls -li original.txt softlink.txt
```
输出会类似：
```
123456 -rw-r--r--  1 user  group  12 Jan 1 12:00 original.txt
654321 lrwxr-xr-x  1 user  group  12 Jan 1 12:01 softlink.txt -> original.txt
# ^^^^^ 不同的 inode 号
```
`softlink.txt` 就像一个快捷方式文件。当你访问 `softlink.txt` 时，系统会读取这个快捷方式文件里的路径 `original.txt`，然后去找到 `original.txt` 的 inode，最后访问到数据。
如果此时你把 `original.txt` 删除了，就相当于删除了快捷方式指向的目标。你再访问 `softlink.txt` 时，系统会提示“No such file or directory”。

---

### 与 pnpm 的关系

npnpm 正是利用了这个机制来实现高效存储：

1.  **内容可寻址存储**：所有下载的包都被全局存储在一个中央仓库（`~/.pnpm-store`）中。这里的每个文件都是唯一的。

2.  **硬链接**：当你执行 `pnpm install` 时，pnpm 并不会把包的文件复制到项目的 `node_modules` 里，而是**创建硬链接**，指向存储仓库中的文件。这样，物理磁盘上只有一份真实数据，但所有项目都能访问到。

3.  **符号链接**：为了构建正确的依赖树结构（比如隔离依赖，避免幽灵依赖），pnpm 会使用**符号链接**来组织 `node_modules` 中的目录结构。你会在 `node_modules` 里看到很多指向全局存储中某个具体位置的符号链接。

这种“**硬链接节省空间 + 符号链接构建结构**”的组合拳，是 pnpm 又快又省空间的核心秘诀。