x-frame-options: ALLOWALL 允许iframe被其它域名嵌套

将类数组转换成真数组，以 `arguments` 为例：
```JS
Array.prototype.slice.call(arguments) // 或是简化成： [].slice.call(arguments)
Array.prototype.slice.apply(arguments) // 或是简化成： [].slice.apply(arguments)
Array.from(arguments)
[...arguments]
```

script defer 渲染完再执行
script async 下载完就执行
```html
<script src='xxx'></script>
<script src='xxx' defer></script>
<script src='xxx' async></script>
```

| script标签 | JS执行顺序 | 是否阻塞解析HTML |
| ----------- | ----------- | ----------- |
| `<script>` | 在HTML中的顺序 | 阻塞（下载执行均阻塞） |
| `<script defer>` | 在HTML中的顺序？ | 不阻塞（下载执行均不阻塞） |
| `<script async>` | 网络请求返回顺序 | 可能（下载不阻塞，执行阻塞） |

link preload 立即加载资源
link prefetch 空闲时加载资源
加载的资源并不会执行，不阻塞页面

## 防抖
- 思路
1、当触发事件停止一段时间后，我们才执行逻辑代码
2、当持续触发事件时，我们不执行逻辑代码
- 实现，，见代码片断

## 节流
- 思路
当持续触发事件时，我们会依旧每隔一段时间执行一次逻辑代码
- 实现，见代码片断

## HTTP2.0
- 二进制传输

- 头部压缩

- 多路复用
多个 Tcp 连接 => keep-alive => 管道化 => 多路复用

- 服务端push
前端在访问特定地址的时候，服务端可以顺带推送静态资源给前端，
如果浏览器已经有缓存，推送就是浪费带宽。即使推送的文件版本更新，浏览器也会优先使用本地缓存。
一种解决办法是，只对第一次访问的用户开启服务器推送（根据 Cookie 判断是否为第一次访问）

## OSI七层网络结构
物理层：IEEE
数据链路层：PPP
网络层：IP、ICMP
传输层：UDP、TCP
会话层：SMTP、DNS
表示层：
应用层：FTP、HTTP

## 常见状态码：
2XX 成功
3XX 重定向
4XX 客户端错误
5XX 服务端错误

304 not-modified 有缓存

## 常用缓存配置策略
- 禁止缓存 `Cache-Control: no-store`
- 缓存静态资源 `Cache-Control: public, max-age=31536000`
- 需要重新验证 `Cache-Control: no-cache` 或 `Cache-Control: max-age=0, must-revalidate`

## CORS
什么情况下需要CORS:
- XMLHttpRequest 或 Fetch 发起的跨源HTTP请求
- Web字体（CSS中通过@font-face使用跨源字体资源）
- WebGL贴图
- 使用`drawImage`将Images/video 画面绘制到canvas

## 安全
XSS（跨站脚本攻击）防范：
- 代码里对用户输入的地方需要仔细检查长度和对“<”“>”“,”“'”等字符串做过滤
- 任何内容写到页面之前都必须加以encode，避免不小心把html tag弄出来
- 避免直接在cookie中泄露用户隐私，例如email、密码等
- 如果网站不需要在浏览器对cookie进行操作，可以在set-cookie末尾加上HttpOnly来防止js代码直接获取cookie
CSRF（跨站请求伪造）防范：
- 后端验证referer字段（不可靠，因为可以伪造）
- token验证
- 前端cookie不跨站 `SameSite`属性（strict, Lax, None）

HTTPS：对称加密算法加密数据+非对称加密算法交换密钥+数字证书验证身份=安全

## Window：load 事件
`load` 事件在整个页面及所有依赖资源如样式表和图片都已完成加载时触发。
它与 `DOMContentLoaded` 不同，后者只要页面 `DOM` 加载完成就触发，无需等待依赖资源的加载
```js
addEventListener('load', (event) => {})
```

## 自动或隐式全局变量创建
直接查找不存在的变量会报错`X is not defined`，
对未声明对变量赋值，在非严格模式下，如果在顶层（全局作用域）中也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量。但在严格模式下，禁止自动或隐式地创建全局变量，会报错`X is not defined`
```js
function foo(a) {
  console.log(a + b) // b is not defined
  b = a
}
foo(2)
```

```js
'use strict'
function foo(a) {
  b = a // b is not defined
  console.log(a + b)
}
foo(2)
```

```js
function foo(a) {
  b = a
  console.log(a + b) // 4
  // window.b === 2
}
foo(2)
```

```js
a1 = a2 = 3
// a2 === 3, a1 === 3, windonw.a2 === 3, window.a1 === 3
var b1 = b2 = 4
// b2 === 4, b1 === 4, window.b2 === 4, window.b1 === 4
let c1 = c2 = 5
// c2 === 5, c1 === 5, window.c2 === 5, window.c1 === undefined
```

```js
'use strict'
a1 = a2 = 3
// a2 is not defined
```

## class this 指向

类的方法内部如果含有`this`，它默认指向类的实例，但也可能丢失

```js
class Logger {
  printName(name = 'there') {
    this.print(`Hello ${name}`)
  }
  print(text) {
    console.log(text)
  }
}

const logger = new Logger()
const { printName } = logger
printName() // TypeError: Cannot read property 'print' of undefined
```

上面代码中，printName方法中的this，默认指向Logger类的实例。但是，如果将这个方法提取出来单独使用，this会指向该方法运行时所在的环境（由于 class 内部是严格模式，所以 this 实际指向的是undefined），从而导致找不到print方法而报错

解决方案：

1 在构造方法中绑定`this`

```js
class Logger {
  constructor() {
    this.printName = this.printName.bind(this)
  }
}
```

2 使用箭头函数，利用 `ES2022` 实例属性的新写法

```js
class Logger {
  printName = (name = 'there') => this.print(`Hello ${name}`)
}
```

新写法定义的属性是实例对象自身的属性，而不是定义在实例对象的原型上

3 使用 `Proxy`, 获取方法的时候，自动绑定 `this`

```js
function selfish(target) {
  const cache = new WeakMap()
  const handler = {
    get (target, key) {
      const value = Reflect.get(target, key)
      if (typeof value !== 'function') {
        return value
      }
      if (!cache.has(value)) {
        cache.set(value, value.bind(target))
      }
      return cache.get(value)
    }
  }
  const proxy = new Proxy(target, handler)
  return proxy
}
const logger = selfish(new Logger())
```

## 创建和触发自定义事件
```js
// 创建自定义事件
var event = new CustomEvent('build', {
  detail: 'custom data', // 自定义数据
  bubbles: true, // 该事件能否冒泡
  cancelable: true, // 该事件是否可以取消
})

// 自定义事件监听
elem.addEventListener('build', () => {}, false)

// 自定义事件触发
elemTarget.dispatchEvent(event)
```

## 常用的 Observer
- `IntersectionObserver`
位置观察者
- `ResizeObserver`
尺寸观察者
- `MutationObserver`
元素观察者

## async 函数返回值
`async` 函数根据返回值类型，等待时间不同
- return 非thenable,非promise 不等待
- return thenable，等待1个then的时间
- return promise，等待2个then的时间

## requestIdleCallback 与 requestAnimationFrame
`requestIdleCallback` 会在浏览器空闲的时候触发，可用来处理一些不重要不紧急的事，如数据分析和上报，预加载，拆分耗时任务，会在浏览器重绘之后调用
`requestAnimationFrame` 会在下一次重绘之前调用

## 常见的微任务和宏任务
微任务: 
- promise.then()
- MutationObserver
- process.nextTick（Node.js环境，node微任务会在nextTick之后，下一个tick之前执行）

宏任务:
- script（整体代码）
- setTimeout
- setInterval
- MessageChannel（比setTimeout早执行）
- setImmediate（Node.js环境）

## 原生生成密码学安全的随机数
```js
crypto.randomUUID()
```

## 会导致重排的方法
<!-- `getSelection` 获取选择的文本范围或光标当前的位置 -->

## 会导致重绘的方法
