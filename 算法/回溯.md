```js
// 全排列
function pai(arr) {
  const res = []
  let path = []
  const backtracking = () => {
    if (path.length === arr.length) {
      res.push([...path])
      return
    }
    for (let i = 0; i < arr.length; i++) {
      if (path.includes(arr[i])) {
        continue
      }
      path.push(arr[i])
      backtracking(path)
      path.pop()
    }
  }
  backtracking()
  return res
}
function pai(arr) {
  const res = []
  const path = []
  const used = new Array(arr.length).fill(false)
  const backtracking = () => {
    if (path.length === arr.length) {
      res.push([...path])
      return
    }
    for (let i = 0; i < arr.length; i++) {
      if (used[i] == true) continue
      used[i] = true
      path.push(arr[i])
      backtracking(path)
      path.pop()
      used[i] = false
    }
  }
  backtracking()
  return res
}
pai([1, 2, 3])


// 回溯所有子集
function allSub(arr) {
  const res = []
  let path = []
  const dfs = (start) => {
    res.push([...path])
    // 下面的结束条件可以省略
    if (path.length === arr.length) {
      return
    }
    for (let i = start; i < arr.length; i++) {
      path.push(arr[i])
      dfs(i + 1)
      path.pop()
    }
  }
  dfs(0)
  return res
}
allSub([1, 2])

// 电话号码字母组合问题，回溯处理多层循环
function phoneMap(num) {
  const map = ['','','abc','def','ghi','jkl','mno','pqrs','tuv','wxyz']
  const res = []
  let path = []
  const arr = Array.from(String(num))
  const dfs = (index) => {
    if (path.length === arr.length) {
      res.push(path.join(''))
      return
    }
    for (let v of map[arr[index]]) {
      path.push(v)
      dfs(index + 1)
      path.pop()
    }
  }
  dfs(0)
  return res
}
phoneMap(2373)

// 给定两个整数 n 和 k，返回 1 至 n 中所有可能的 k 个数的组合
// 示例:
// 输入: n = 4, k = 2
// 输出:
// [
// [2,4],
// [3,4],
// [2,3],
// [1,2],
// [1,3],
// [1,4],
// ]
function comb(n, k) {
  let res = []
  const arr = Array.from({ length: n }, (i, idx) => idx + 1)
  let path = []
  const backtracking = (startIndex) => {
    if (path.length === k) {
      res.push([...path])
      return
    }
    for (let i = startIndex; i < n; i++) {
      path.push(arr[i])
      backtracking(i + 1)
      path.pop()
    }
  }
  backtracking(0)
  return res
}
comb(4, 2)

// 组合总和
// 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
// candidates 中的数字可以无限制重复被选取。
// 说明：
// 所有数字（包括 target）都是正整数。
// 解集不能包含重复的组合。
// 示例 1：
// 输入：candidates = [2,3,6,7], target = 7,
// 所求解集为：
// [
// [7],
// [2,2,3]
// ]
// 示例 2：
// 输入：candidates = [2,3,5], target = 8,
// 所求解集为：
// [
//   [2,2,2,2],
//   [2,3,3],
//   [3,5]
// ]
function sum(candidates, target) {
  let res = []
  const getSum = (arr) => arr.reduce((prev, cur) => prev + cur, 0)
  let path = []
  const backtracking = (startIndex) => {
    const mySum = getSum(path)
    if (mySum === target) {
      res.push([...path])
    }
    if (mySum > target) {
      return
    }
    for (let i = startIndex; i < candidates.length; i++) {
      path.push(candidates[i])
      backtracking(path, i)
      path.pop()
    }
  }
  backtracking(0)
  return res
}
sum([2, 3, 6, 7], 7)

// 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
// candidates 中的每个数字在每个组合中只能使用一次。
// 说明：
// 所有数字（包括目标数）都是正整数。
// 解集不能包含重复的组合。
// 示例 1:
// 输入: candidates = [10,1,2,7,6,1,5], target = 8,
// 所求解集为:
// [
// [1, 7],
// [1, 2, 5],
// [2, 6],
// [1, 1, 6]
// ]
// 示例 2:
// 输入: candidates = [2,5,2,1,2], target = 5,
// 所求解集为:
// [
//   [1,2,2],
//   [5]
// ]

function sum(candidates, target) {
  candidates = candidates.sort((a, b) => a - b)

  let res = []
  let path = []
  // 排序，让相同元素挨着
  const used = new Array(candidates.length).fill(false)
  const getSum = (arr) => arr.reduce((prev, cur) => prev + cur, 0)
  const backtracking = (startIndex) => {
    const mySum = getSum(path)
    if (mySum === target) {
      res.push([...path])
    }
    if (mySum > target) {
      return
    }

    for (let i = startIndex; i < candidates.length; i++) {
      if (i > 0 && candidates[i] === candidates[i - 1] && used[i - 1] === false) {
        continue
      }
      used[i] = true
      path.push(candidates[i])
      backtracking(path, i + 1)
      path.pop()
      used[i] = false
    }
  }
  backtracking(0)
  return res
}
sum([10,1,2,7,6,1,5], 8)

// 组合总和3
// 找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。
// 说明：
// 所有数字都是正整数。
// 解集不能包含重复的组合。
// 示例 1:
// 输入: k = 3, n = 7
// 输出: [[1,2,4]]
// 示例 2:
// 输入: k = 3, n = 9
// 输出: [[1,2,6], [1,3,5], [2,3,4]]
function sum(n, k) {
  let res = []
  let path = []
  const getSum = (arr) => arr.reduce((prev, cur) => prev + cur, 0)
  const backtracking = (startIndex) => {
    if (path.length === k) {
      if (getSum(path) === n) {
        res.push([...path])
      }
      return
    }
    for (let i = startIndex; i <= 9; i++) {
      path.push(i)
      backtracking(path, i + 1)
      path.pop()
    }
  }
  backtracking(1)
  return res
}
sum(9, 3)

// 分割回文串
// 给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。
// 返回 s 所有可能的分割方案。
// 示例:
// 输入: "aab"
// 输出:
// [
// ["aa","b"],
// ["a","a","b"]
// ]
function splitStr(s) {
  const isHui = (str, start, end) => {
    for (let i = start, j = end; i <= j; i++, j--) {
      if (str[i] !== str[j]) {
        return false
      }
    }
    return true
  }
  let res = []
  let path = []
  const backtracking = (startIndex) => {
    if (startIndex >= s.length) {
      res.push([...path])
      return
    }
    for (let i = startIndex; i < s.length; i++) {
      if (isHui(s, startIndex, i)) {
        path.push(s.slice(startIndex, i + 1))
      } else {
        continue
      }
      backtracking(i + 1)
      path.pop()
    }
  }
  backtracking(0)
  return res
}
splitStr('aab')

//  复原IP地址
// 给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。
// 有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。
// 例如："0.1.2.201" 和 "192.168.1.1" 是 有效的 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效的 IP 地址。
// 示例 1：
// 输入：s = "25525511135"
// 输出：["255.255.11.135","255.255.111.35"]
// 示例 2：
// 输入：s = "0000"
// 输出：["0.0.0.0"]
// 示例 3：输入：s = "1111"
// 输出：["1.1.1.1"]
// 示例 4：输入：s = "010010"
// 输出：["0.10.0.10","0.100.1.0"]
// 示例 5：输入：s = "101023"
// 输出：["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]
function revertIp(s) {
  let res = []
  let path = []
  const isIp = (s, start, end) => {
    const str = s.slice(start, end + 1)
    if (str.length > 1 && str.startsWith('0')) {
      return false
    }
    return Number(str) <= 255
  }
  const backtracking = (startIndex) => {
    if (startIndex >= s.length) {
      if (path.length === 4) {
        res.push(path.join('.'))
      }
      return
    }

    for (let i = startIndex; i < s.length; i++) {
      if (isIp(s, startIndex, i)) {
        path.push(s.slice(startIndex, i + 1))
      } else {
        continue
      }
      backtracking(i + 1)
      path.pop()
    }
  }
  backtracking(0)
  return res
}
revertIp('0000')
```